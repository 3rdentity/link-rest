<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="protocol">
    <title>LinkRest Protocol</title>
 
    <section xml:id="protocol-overview">
        <title>Overview</title>
      <para>LinkRest Protocol is a simple HTTP/JSON-based message protocol. It operates on an object
         model implicitly shared between a client and a server. It defines the format of JSON
         documents exchanged between client and server, and a set of control parameters that let the
         client to control representation of the model returned from the server. E.g. the client may
         request a range of objects, sorted in a specific order, matching a criteria, with each
         object including a subset of attributes and related entities. This gives the client exactly
         what it needs, thus simplifying the code, minimizing the number of trips to the server, and
         optimizing the size of the response.</para>
      <para><code>application/json</code> is used in both requests and responses where applicable.
         Values of some control parameters below are also represented as JSON.</para>
      <para>All examples below use an imaginary CMS data model that is made of 2 entities: Domain
         and Article, with a 1..N relationship between them: </para> <para><inlinemediaobject>
            <imageobject>
               <imagedata fileref="img/model.png"/>
            </imageobject>
         </inlinemediaobject></para>
    </section>
   
   <section xml:id="protocol-json-documents">
      <title>JSON Documents</title>
      <section xml:id="protocol-simple-document">
         <title>Response: Simple Document</title>
         <para>This document is used in responses that contain no data, just a boolean status and a
            message. On success it might look like
            this:<programlisting language="json">HTTP/1.1 200 OK
Content-Type: application/json

{
   "success" : true,
   "message" : "all is good"
} </programlisting>On
            failure it might look like
            this:<programlisting>HTTP/1.1 500 Server error
Content-Type: application/json    

{
   "success" : false,
   "message" : "Database connection failure"
} </programlisting></para>   
      </section>
      <section xml:id="protocol-collection-document">
         <title>Response: Collection Document</title>
         <para>A document that passes the data from the server to the client. This is the main
            representation of data in
            LinkRest.<programlisting>HTTP/1.1 200 OK
Content-Type: application/json

{
   "success" : true,
   "data" : [
      { "id" : 5, "name": "A" },
      { "id" : 8, "name": "B" }
   ],
   "total" : 2
}</programlisting></para>
         <para><code>"data"</code> array contains entity objects. Implicit entity model defines what
            attributes and relationships (collectively - "properties") each object has. A subset of
            properties showing in the collection document is a defined by a combination of
            server-side constraints and client request control parameters. Each object in the data
            array may contain related objects, those in turn may contain their related objects, with
            no limit on the depth of nesting.</para>
         <para><code>"total"</code> is a number of objects one would see in the collection if there
            was no pagination. If pagination is in use (see <xref linkend="protocol-start-limit"/>),
            the total may be greater than the number of visible objects in the "data" array.
            Otherwise it is equal to the size of "data".</para>   
      </section>
      <section xml:id="protocol-update-document">
         <title>Request: Update Document</title>
         <para>Update Document is sent from the client to the server to modify an entity collection.
            It is a Collection document stripped down to its "data" section. There are two flavors -
            a single object and an array of
            objects:<programlisting>{ "id" : 5, "name": "X" } </programlisting><programlisting>[
   { "id" : 5, "name": "X" },
   { "id" : 8, "name": "Y" }
] </programlisting></para>   
      </section>
   </section>
   
   <section xml:id="protocol-json-datetime">
      <title>Dates and Times in JSON</title>
      <para>JSON doesn't have a datatype for either date or time. Both are represented as strings.
         Both server and client must ensure that date/time strings are in <link xlink:href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601 format</link>.
         E.g.:<programlisting>2015-04-19T11:08:53Z
2015-04-10T11:08
2015-04-19</programlisting></para>
      <para>Developers should not assume that the server is in the same time zone as the browser.
         All timezone-aware expressions should contain time zone offset or "Z" suffix (for "Zulu"
         time).</para>
   </section>

    <section xml:id="protocol-control-parameters">
       <title>Control Parameters</title>
      <para>Control parameters, usually passed as URL keys, apply to the Collection Document and let
         the server to provide a single generic endpoint per entity, while still allowing the client
         to shape up the response Collection to its liking. These parameters are normally used with
         GET, however POST/PUT can also return a Collection Document, so many of the parameters are
         also applicable when modifying the data.</para>
       <section xml:id="protocol-cayenneExp">
          <title>Filtering Collection with <code>cayenneExp</code></title>
         <para>A conditional expression that is used to filter the response objects. Expression
            String should follow the <link
               xlink:href="http://cayenne.apache.org/docs/4.0/cayenne-guide/expressions.html">format
               understood by Cayenne</link> (hence the name - "cayenneExp"). The root for the
            property paths is the request entity (unless "cayenneExp" is used within a relationship
            "include", in which case the root is that related entity). </para>
         <para>Example 1: Filtering on a single property.</para>
         <para><code>cayenneExp=vhost='linkrest.org' </code></para>
         <para>Example 2: Filtering using outer join (the "+" sign is Cayenne notation for
            outer).</para>
         <para><code>cayenneExp=articles+ = null</code></para>
         <para>Example 3: Filtering with parameters using positional bindings.</para>
         <para><code>cayenneExp=["articles.body like $b","%LinkRest%"]</code></para>
         <para>Example 4: Filtering with parameters using named bindings.</para>
         <para><code>cayenneExp={ "exp" : "articles.body like $b", "params":
               {"b":"%LinkRest%"}}</code></para>
       </section>
       <section xml:id="protocol-sort-dir">
          <title>Ordering Collection with <code>sort</code> / <code>dir</code></title>
         <para>Example 1: Sort on a single property.</para>
         <para><code>sort=vhost </code></para>
         <para>Example 2: Sort descending on a property.</para>
         <para><code>sort=id&amp;dir=DESC </code></para>
         <para>Example 3: Same as 2, but sort is a JSON object.</para>
         <para><code>sort={"property":"vhost","direction":"DESC"} </code></para>
         <para>Example 4: Multiple sortings as a single JSON structure.</para>
         <para><code>sort=[{"property":"name"}, "property":"vhost","direction":"DESC"}] 
            </code></para>
       </section>
       <section xml:id="protocol-start-limit" xreflabel="Pagination">
         <title>Pagination with <code>start</code> / <code>limit</code></title>
         <para>These two parameters are used together to request from the server a range of objects
            for a potentially huge collection. They allow to implement efficient data pagination on
            the client.</para>
         <para><code>"start"</code> is an offset within the "data" array. All the objects below this
            offset are discarded from the collection. Default "start" is 0. </para>
         <para><code>"limit"</code> is a maximum number of objects in the collection "data". Default
            is infinity (no limit). </para>
         <para>"limit" is applied after "start". So for a collection with a total of 10 objects,
               <code>?start=2&amp;limit=5</code> would result in objects 2..6 returned from the
            server. Returned Collection "total" would still be 10.</para>
      </section>
       <section xml:id="protocol-include-exclude">
          <title>Shaping Collection Entities with <code>include</code> /
            <code>exclude</code></title>
         <para>Model entities may have "simple" properties (attributes) and properties that point to
            related entities (relationships). By default Collection Document contains entity
            representation that includes its "id", all of its attributes, and none of the
            relationships. "include" and "exclude" parameters allow the client to request a specific
            subset of entity properties, including related entities. Some examples are given below,
            showing include/exclude parameters and resulting entity contents.</para>
         <para>Example 1: Include default properties (all entity attributes) minus "vhost"
            attribute. </para>
         <para><code>exclude=vhost</code><programlisting>{ "id" : 45, "name" : "LinkRest Site" } </programlisting></para>
         <para>Example 2: Exclude all properties, but "id".</para>
         <para/>
          <para><code>include=id</code><programlisting>{ "id" : 45 } </programlisting></para>
         <para>Example 3: Multiple includes, one of them points to attributes of related
            entity.</para>
         <para><code>include=id&amp;include=articles.title </code><programlisting>{
   "id" : 45,
   "articles" : [
      { "title" : "LinkRest Includes" }, 
      { "title" : "Other Tech News" },
      { "title" : "Introducing LinkRest" }
   ]
}</programlisting></para>
         <para>Example 4: Advanced include. Include specification can itself be a JSON object and
            contain "cayenneExp" and "sort" directives shaping up a collection of related objects
            for each root object.</para>
          <para><code>include={"path":"articles","cayenneExp":"title like
            '%LinkRest%'","sort":"title"} &amp;include=articles.title </code></para>
         <programlisting language="json">{
   "id":45,
   "articles" : [
      { "title" : "Introducing LinkRest" },
      { "title" : "LinkRest Includes" }
   ]
}</programlisting>
         <para>Example 5: Related objects as a map. Here we'll map article bodies by title.</para>
         <para><code>include={"path":"articles","mapBy":"title"}&amp;include=articles.body</code> <programlisting>{
   "articles" : {   
      "Introducing LinkRest" : { "body" : "LinkRest is a .." },   
      "LinkRest Includes" : { "body" : "Includes are .." }   
   }
}</programlisting></para>
       </section>
    </section>
   
   <section xml:id="protocol-extensions">
      <title>Protocol Extensions</title>
      <para>With the help of <link
            xlink:href="https://github.com/nhl/link-rest/blob/master/src/main/java/com/nhl/link/rest/runtime/adapter/LinkRestAdapter.java"
            >LinkRestAdapter</link> and other LinkRest extension techniques one can extend or
         customize the protocol to recognize extra control parameters, etc. LinkRest ships with one
         such optional extension that adapts the framework for the use with Sencha/ExtJS JavaScript
         client. This extension is described below.</para>
      <section xml:id="sencha-adapter">
         <title>Sencha Adapter</title>
         <para><link
               xlink:href="https://github.com/nhl/link-rest/blob/master/src/main/java/com/nhl/link/rest/runtime/adapter/sencha/SenchaAdapter.java"
               >SenchaAdapter</link> provides a few extensions to the LinkRest protocol to better
            handle certain Sencha features:<itemizedlist>
               <listitem>
                  <para>If a to-one relationship property is included in the Collection, the
                     framework would also generate a companion "synthetic" FK property called
                     "propertyName_id"</para>
               </listitem>
               <listitem>
                  <para><code>"filter"</code> key - an alternative to
                     <code>"cayenneExp"</code>.</para>
               </listitem>
               <listitem>
                  <para><code>"group"</code> / <code>"groupDir"</code> keys that are functionally
                     equivalent to <code>"sort"</code> / <code>"dir"</code>.</para>
               </listitem>
            </itemizedlist></para>
      </section>
   </section>
</chapter>
