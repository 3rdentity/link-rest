<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0" xml:id="framework">
    <title>LinkRest Framework</title>
    
    <section xml:id="framework-include">
        <title>Prerequisites</title>
        <para>
            <itemizedlist>
                <listitem>
                    <para>Java 1.7 or newer</para>
                </listitem>
                <listitem>
                    <para>A Java "war" project that will serve your REST requests.</para>
                </listitem>
                <listitem>
                    <para>A JAX-RS 2.0 container, such as Jersey 2.x.</para>
                </listitem>
                <listitem>
                    <para>Cayenne 4.0.M2 or newer. Mapping your database and starting Cayenne
                        ServerRuntime is outside the scope of this document. Please refer to the
                            <link
                            xlink:href="http://cayenne.apache.org/docs/4.0/cayenne-guide/index.html"
                            >corresponding Cayenne docs</link>.</para>
                </listitem>
            </itemizedlist>
        </para>
    </section>
 
    <section xml:id="framework-include">
        <title>Getting Started</title>
        <para>To load LinkRest in your project, follow these simple steps:</para>
        <para>1. Declare LinkRest dependency. Here is a Maven example. If you are using Gradle or
            Ant, you do what needs to be done there to include LinkRest
            dependency.<programlisting language="xml">&lt;dependency>
   &lt;groupId>com.nhl.link.rest&lt;/groupId>
   &lt;artifactId>link-rest&lt;/artifactId>
   &lt;version>1.19&lt;/version>
&lt;/dependency> </programlisting>2.
            Create <code>LinkRestRuntime</code>, and load it in JAX-RS container. Assuming the
            container is Jersey, this may look like
            this:<programlisting language="java">import javax.ws.rs.ApplicationPath;
import org.glassfish.jersey.server.ResourceConfig;
import com.nhl.link.rest.runtime.LinkRestBuilder;

/**
 * A Jersey-specific JAX-RS Application class that loads LinkRest.
 */
@ApplicationPath("/")
public class JaxRsApplication extends ResourceConfig {

	public JaxRsApplication() {

		ServerRuntime cayenneRuntime = ..
        LinkRestRuntime lrRuntime = LinkRestBuilder.build(cayenneRuntime);
        super.register(lrRuntime);

        // continue with Application setup...
        ..
	}
}
</programlisting>
            Now you are ready to write LinkRest endpoints.</para>
    </section>
    
    <section xml:id="framework-programming-endpoints">
        <title>Writing Resource Endpoints</title>
        <para>Let's create a resource class called DomainResource, annotated with JAX-RS @Path and
            @Produces annotations. One extra thing we need for LinkRest to work is a an instance of
                <code>javax.ws.rs.core.Configuration</code>, that can be injected with
                <code>@Context</code>
            annotation:<programlisting language="java">import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Configuration;
import javax.ws.rs.core.Context;

@Path("domain")
@Produces(MediaType.APPLICATION_JSON)
public class DomainResource {

	@Context
	private Configuration config;
}</programlisting></para>
        <section xml:id="framework-endpoints-post">
            <title>Create Entity with POST</title>
            <para>Now let's implement a <code>POST</code> method in DomainResource
                class:<programlisting language="java">import com.nhl.link.rest.LinkRest;
import com.nhl.link.rest.SimpleResponse;

...

@POST
public SimpleResponse create(String data) {
	return LinkRest.create(Domain.class, config).sync(data);
}</programlisting>Here
                we've built a very simple "create chain" using LinkRest fluent API. It starts with a
                static "create" method on LinkRest class, taking a type of entity to create (Domain) and
                previously injected Configuration. Finally it calls "sync" method to execute the
                request. "data" String is expected to be an "Update Document" (see <xref
                    linkend="protocol-update-document"/>), i.e. a single object or an array of objects.
                Now if you compile your app and deploy it in a web container (e.g. Tomcat), you may call
                this endpoint to create new Domain
                objects:<programlisting>curl -i -X POST 'http://example.org/myapp/domain' \
>          -d '{"vhost":"mysite1.example.org","name":"My Site #1"}'

HTTP/1.1 201 Created
Content-Type: application/json

{"success":true}</programlisting></para>
            <para>In your container log you might see output from Cayenne, actually inserting a newly
                created
                object:<programlisting>INFO CommonsJdbcEventLogger - INSERT INTO "domain" ("name", "vhost") VALUES (?, ?)
INFO CommonsJdbcEventLogger - [bind: 1->name:'My Site #1', 2->vhost:'mysite1.example.org']
INFO CommonsJdbcEventLogger - Generated PK: domain.id = 1
INFO CommonsJdbcEventLogger - === updated 1 row.</programlisting></para>
        </section>
        <section xml:id="framework-endpoints-get">
            <title>Read Collection of Entities with GET</title>
        
        <para>You may create more Domain objects, executing <code>POST</code> request above. Now
            let's write a <code>GET</code> method to search for
            domains:<programlisting language="java">import com.nhl.link.rest.DataResponse;
import com.nhl.link.rest.LinkRest;

...

@GET
public DataResponse&lt;Domain> getAll(@Context UriInfo uriInfo) {
	return LinkRest.select(Domain.class, config).uri(uriInfo).select();
}</programlisting></para>
        <para>The above is a typical "select chain". Now <code>GET</code> can be invoked from the
                client like
                this:<programlisting>curl -i -X GET 'http://example.org/myapp/domain'

HTTP/1.1 200 OK
Content-Type: application/json

{
    "data" : [
        { "id" : 1, "name" : "My Site #1", "vhost" : "mysite1.example.org" },
        { "id" : 2, "name" : "My Site #2", "vhost" : "mysite2.example.org" }
    ],
    "total" : 2
}</programlisting>Since
                select chain above incorporates UriInfo, it will recognize LinkRest control
                parameters passed from the client (see <xref linkend="protocol-control-parameters"
                />). Let's try using "cayenneExp" filter and
                "include":<programlisting>curl -i -X GET 'http://example.org/myapp/domain?cayenneExp=vhost="mysite1.example.org"&amp;include=id'

HTTP/1.1 200 OK
Content-Type: application/json

{
    "data" : [
        { "id" : 1 }
    ],
    "total" : 1
}</programlisting></para>
        </section>
        <section xml:id="framework-endpoints-get-one">
            <title>Read a Single Entity with GET</title>
            <para>A common request is to locate a single instance of an entity by ID. Here is how
                this can be done with
                LinkRest:<programlisting>@GET
@Path("{id}")
public DataResponse&lt;Domain> getOne(@PathParam("id") int id, @Context UriInfo uriInfo) {
	return LinkRest.select(Domain.class, config).byId(id).uri(uriInfo).selectOne();
}</programlisting>Here
                we are binding "id" as a URL path parameter, but also notice that LinkRest doesn't
                mandate any specific place in the URL for ID. This is a decision made by the
                developer. Calling this endpoint, we'll get an expected
                result:<programlisting>curl -i -X GET 'http://example.org/myapp/domain/1'

HTTP/1.1 200 OK
Content-Type: application/json

{
    "data" : [
        { "id" : 1, "name" : "My Site #1", "vhost" : "mysite1.example.org" }
    ],
    "total" : 1
}</programlisting>Even
                though we expect at most one object to be returned, the response is the same
                Collection Document as we've seen before.</para>
        </section>
    </section>
    
    <section xml:id="framework-chains">
        <title>Request Chains</title>
        <para>As the examples above demonstrate, to process a given request, you need to build an
            appropriate LinkRest "chain".  Each chain starts with a call to a static method of
            LinkRest class, that determines chain type, parameters it can take, and the type of
            response it generates. Each chain type naturally maps to a single HTTP method. Although
            ultimately the mapping of chains to methods is not enforeced by LinkRest and is left to
            the application developer. The following chains are available:
            <programlisting>// use with @GET
LinkRest.select(SomeEntity.class, config)...

// use with @DELETE
LinkRest.delete(SomeEntity.class, config)...

// use with @POST
LinkRest.create(SomeEntity.class, config)...

// use with @POST
LinkRest.createOrUpdate(SomeEntity.class, config)...

// use with @PUT
LinkRest.idempotentCreateOrUpdate(SomeEntity.class, config)...

// use with @PUT
LinkRest.idempotentFullSync(SomeEntity.class, config)...

// use with @GET for metadata endpoints
LinkRest.metadata(SomeEntity.class, config)...
</programlisting></para>
    </section>
    
    <section xml:id="framework-pojo">
        <title>Non-Persistent Properties</title>
    </section>
    
    <section xml:id="framework-security">
        <title>Implementing Security Policies</title>
    </section>
    
    <section xml:id="framework-customize-stack">
        <title>Customizing Request Processing</title>
    </section>
</chapter>
